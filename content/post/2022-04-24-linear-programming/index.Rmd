---
title: "Linear Programming"
author: "HU Runqiu"
date: 2022-04-24T21:13:14-05:00
categories: ["Academic Notes"]
tags: ["Operations Research", "Optimization"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

```{python echo = FALSE}
import matplotlib.pyplot as plt
import numpy as np
plt.rcParams.update({
    "text.usetex": True,
    "font.family": "sans-serif",
    "font.sans-serif": ["STIX"],
    "text.latex.preamble": r'\usepackage{bm}'})
```

\def\*#1{\mathbf{#1}}

# Constraint的几何意义

每一个Constraint是一个Equation，表示为$\mathbf{a^TX=\beta}$，表示一个平面

-   $\mathbf{a^TX>\beta}$ 表示该平面上半空间（Half Space）
-   $\mathbf{a^TX>\beta}$ 表示该平面下半空间（Lower Space）
-   $\mathbf{a}$ 表示法向量，与该平面垂直，指向使得$\mathbf{a^TX}$增大的方向（$\mathbf{a^TX>\beta}$的方向，即上半空间）

因此，想要$\min \mathbf{c^TX}$，应当向着$-\mathbf{c}$的方向改变X。

如果可行域$P$完全落在某一个平面$\mathbf{-c^Tx}=\beta$对应的平面的下半平面，那么$\mathbf{c^Tx}$在$P$内的最小值有一个下界$-\beta$。

沿着$-c$（法向量）的方向走，目标函数$\mathbf{-c^Tx}$的值越来越大，对应地，沿着$c$（法向量）的方向走，$\mathbf{-c^Tx}$的值越来越小，$\mathbf{c^Tx}$的值越来越大，因此$\mathbf{c^Tx}$的最小值最小只可能是$-\beta$（正好位于平面$\mathbf{c^Tx=-\beta}$）。因此，如果可行域与平面相交，那么最值在交点（或线或平面）处取得。

这也解释了为什么Graphical Method，要求先画出可行区域，之后沿着一个方向（目标函数法向量）移动目标函数的曲线，直到找到与可行域的最后一个交点。

```{python echo=FALSE, results = "hide"}
coord = [[1,1], [2,1], [2,2], [1,2], [0.5,1.5]]
coord = [[1,1], [2,1], [2,2], [1,2], [0.5,1.5]]
coord.append(coord[0]) #repeat the first point to create a 'closed loop'

xs, ys = zip(*coord) #create lists of x and y values
x = np.arange(1.6,2.5,0.1)
y = -x + 4
soa = np.array([[2, 2, 2.1, 2.1]])
X, Y, U, V = zip(*soa)
fig, ax = plt.subplots()
plt.xlim(0.4, 2.7)
plt.ylim(0.8, 2.6)
plt.quiver(X, Y, U, V, scale=5, scale_units='inches', angles = 'xy', color=['red'])
plt.gca().set_aspect('equal', adjustable='box')
plt.plot(xs,ys) 
plt.plot(x, y)
plt.scatter(2,2,zorder=10)
plt.annotate(r"$\bm{x^{\ast}}$", (2.1,1.95))
plt.annotate(r"$-\bm{c^Tx=\beta}$", (2.3,1.5))
plt.annotate(r"$-\bm{c}$", (2.25,2.25))
plt.annotate(r"$P$", (1.25,1.5))
plt.show()
```

> Graphical Method：遍历每一个可行域Polyhedral的交点，根据目标函数得到$-c$的方向，画出对应垂直的平面$\mathbf{-c^Tx=\beta}$，看可行域是否完全位于该平面的下半空间，若找到则最优解也找到，否则继续遍历。

> 方法存在的问题：交点太多，遍历交点的复杂度指数级

# Simplex Method
有效生成和管理可行域交点的方式，避免去每个交点处插旗子（选择性遍历）。

## LP的Fundamental Theorem

有$p$个点$\mathbf{x^1,x^2,\ldots,x^p}$，令 $\mathbf{x}=\sum_{i=1}^p\lambda_i\mathbf{x^i}$，即$p$个点的线性组合。

二维情景：$\*{x^1}=(0,1)^T, \*{x^2}=(1,0)^T$

```{r echo=FALSE,fig.align='center',fig.cap="线性组合示意图", out.width = '80%'}
knitr::include_graphics("https://runqiuhu-1301738355.cos.ap-nanjing.myqcloud.com/202204250917333.png")
```
同样的$\lambda_1+\lambda_2=1$，得到的线性组合（新的点）为$(\lambda_1x^1_1+\lambda_2x^2_1, \lambda_1x^1_2+\lambda_2x^2_2)$，即$(\lambda_1x^1_1+(1-\lambda_1)x^2_1, \lambda_1x^1_2+(1-\lambda_1)x^2_2)=((x_1^1-x_1^2)\lambda_1+x_1^2, (x_2^1-x_2^2)\lambda_1+x_2^2) \rightarrow y=(x-x^2_1)/(x_1^1-x_1^2) * (x_2^1-x_2^2)+x^2_2$，这就是AB形成的直线。因此，

- 当$\lambda_i \ge 0$时，它的空间位于为AB线段：convex combination
- 当不要求$\lambda_i \ge 0$时，它的空间位于AB所在直线：affine combination
- 当不要求$\lambda_1+\lambda_2=1$时，它是整个第一象限：conic combination

直观理解：

- convex组合，两点连线段
- affine组合，两点连成直线
- conic组合，两点到原点连线向外张成的锥（无限向外不封闭）

回到Linear Programming，可行域

$$P=\{\*{x\in R^n} \mid \*{Ax=b, x\ge 0}\}$$
- 是一个Polyhedral Set（$\*{Ax=b}$对应$2m$个Half Space交成的$m$个平面，$n$为$x_i \ge 0$对应的$n$个Half Space

- $P$是convex set

- $P$可看作$m$个平面 $\cap$ 第一象限，为空则无可行解

- 对偶视角：重新看$\*{Ax=b}$

$$
\begin{aligned}
\*{Ax}&=\\
&=\left[ \begin{matrix}
	a_{11}&		a_{12}&		\cdots&		a_{1n}\\
	a_{21}&		a_{22}&		\cdots&		a_{2n}\\
	\vdots&		\vdots&		\ddots&		\vdots\\
	a_{m1}&		a_{m2}&		\cdots&		a_{mn}\\
\end{matrix} \right] \left[ \begin{array}{l}
	x_1\\
	x_2\\
	\vdots\\
	x_n\\
\end{array} \right]\\
&=\left[ \begin{array}{l}
	a_{11}\\
	a_{21}\\
	\vdots\\
	a_{m1}\\
\end{array} \right]x_1+\left[ \begin{array}{l}
	a_{12}\\
	a_{22}\\
	\vdots\\
	a_{m2}\\
\end{array} \right]x_2+\ldots+\left[ \begin{array}{l}
	a_{1n}\\
	a_{2n}\\
	\vdots\\
	a_{mn}\\
\end{array} \right]x_n
\end{aligned}
$$

此时，由于$x_i\ge 0$，可以看做是$n$个$m$维向量$A_i$在$x_i$作用下张成的锥空间，判断如果$b$落在这个锥内，那么问题有解。


## 如何得到Extreme Point

将原问题化为标准形式（添加slack variable等）后，得到$\*{Ax=b}$，假设得到的方程组有$n$个变元，$m$个等式，通常变元多于等式 ($n>m$)，那么将$n-m$个变元设为0，剩余$m$未知数有$m$个方程，可以求出一个唯一解。这$m$个非0和$n-m$个0组成的一个解，就是一个extreme point。

注意：$m$未知数及$m$个方程能得到解的前提是，这个$m*m$的方阵是可逆的，即列之间是线性无关的。（反例：2x+y=1, 4x+2y=1，$(2,4)=2(1,2)$)

因此，选择为非0的变元对应的矩阵，最好是列线性无关的。

定理：$\*{x}=(x_1,x_2,\ldots,x_i)$是extreme point的充要条件：

$x_i>0$所对应的系数矩阵列之间线性无关。


$\*{Ax=b}$，将其分解开：$\*{B}_{m\times m}\underbrace{\*{x_B}}_{basic\ variables} + \*{N}_{(n-m)\times (n-m)}\underbrace{\*{x_N}}_{non-basic\ variables}$，得到$\*{B}_{m\times m}\*{x}_B=\*{b}$，则$\*{x}_B=\*{B^{-1}b}$，这叫做basic solution

如果还能保证$\*{x}_B=\*{B^{-1}b} \ge 0$，则为basic feasible solution

显然，从$n$个变元选$n-m$个变元设为0，有$C(n,n-m)=C(n,m)$个选法，即有$C(n,m)$个basic solution，而basic feasible solution只可能比这个少，具体是否feasible需要逐个验证。

LP的可行域一定是convex的。当可行域是有界时，可行域内任意一点都可以通过extreme的convex组合表示出来。

```{r echo=FALSE,fig.align='center',fig.cap="Extreme Point Convex组合表示任意点", out.width = '80%'}
knitr::include_graphics("https://runqiuhu-1301738355.cos.ap-nanjing.myqcloud.com/202204250918911.jpg")
```

当可行域无界，需要一个方向$\*{d}$，任意一个可行域内的点，沿着这个方向走任意远，还在这个可行域内，将这个方向称作extremal direction

- 如果有这个extremal direction $\Leftrightarrow$ $P$无界（有界的话肯定会冲出去）
- $\*{Ax=b}$，$\*{x}$沿着$\lambda\*{d}$走任意远到达的点为$\*{x}+\lambda\*{d}$，要这个点还在$P$内，那么有$\*{A}(\*{x}+\lambda\*{d})=\*{b}$，则$\*{Ax}+\lambda\*{Ad}=\*{b}$，则$\lambda\*{Ad}=0$，只能是$\*{Ad=0}$，并且为了保证non-neg，即$\*{x}+\lambda\*{d}\ge 0$，$\*{d}$必须>0（否则$\lambda$走远，无论x如何，都会负）

综合结论，得到Resolution Theorem:

$V$是extreme point的合集，$v_i \in V, i \in I$，$I$是有限下标集合（不超过$C(n,m)$），那么$P$中任何一点可以表示为

$$\*{x}=\sum_{i\in I} \lambda_i v_i +s\*{d}$$
前半部分是convex的线性组合（找到一个起点），后半部分对于有界的$P$，$s=0$；否则$s>0$就是extremal direction（找到一个方向，从起点出发无限开车）。

注意到目标函数$\*{c^Tx}=\sum\lambda_i\*{c^T}v_i+s\*{c^Td}$，即目标函数值由extreme point对应的函数值，加上系数在extremal方向上的投影值决定。

对最小化问题，观察$\*{c^Tx}=\sum\lambda_i\*{c^T}v_i+s\*{c^Td}$：

- $\*{c^Td}<0$，那么$s$不断增大，$s\*{c^Td}$无限小，可至负无穷（unbounded）
- $\*{c^Td}>0$，$\*{c^Tx}=\sum\lambda_i\*{c^T}v_i+s\*{c^Td}>\sum\lambda_i\*{c^T}v_i\ge\sum\lambda_i\min_i\*{c^T}v_i=cv_{min}\cdot(\sum\lambda_i)=cv_{min}$，因此，任意$P$内的$x$，得到的目标函数值都比最小$c^T\cdot$(extreme points)要大，那么最优解在最小$c^T\cdot$(extreme points)取得。
- 不存在d，即任意点都可以extreme point的convex组合表示，与上一个情况类似，推导第一步直接取等号。

得到的结论：

- LP的可行域非空，那么至少会有一个Extreme Point。
- P非空，并且目标函数值不是unbounded，则LP在至少一个extreme point取得最值
- P有有穷多个顶点
- 顶点从代数上看是BFS


代数与图形之间的对应：我们希望一个BFS对应一个vertex，因为vertex有限，那么搜索最优只需要遍历vertex，一定是有穷的。

但是实际并不是一一对应，可能出现一个vertex对应多个BFS。原因：当basic-variable的值里出现0，和non-basic variable里的0难以区分，0的分配会有多种组合。

Ax=b 矩阵表示为

$$
\begin{gathered}
\mathrm{A}=[\mathrm{B} \mid \mathrm{N}] \\
\mathrm{x}=\left[\begin{array}{c}
\mathrm{x}_{\mathrm{B}} \\
\mathrm{x}_{N}
\end{array}\right]=\left[\begin{array}{c}
\mathbf{B}^{-1} \mathrm{b} \\
\mathbf{0}
\end{array}\right]
\end{gathered}
$$
这样$Ax$相乘只能得到$Bx_B$，
为了在结果中显示出non-basic的0，A变换为

$$
M=\left[\begin{array}{ll}
B & N \\
0 & I
\end{array}\right]
$$
如此，得到
$$
\*{Mx}=\left[\begin{array}{c}
\mathbf{x_B} \\
\mathbf{x_N}
\end{array}\right]=\left[\begin{array}{c}
\mathbf{Bx_B+Nx_N=b} \\
\mathbf{0x_B+Ix_N=0}
\end{array}\right]
$$
M称为fundamental matrix，$\*{M^{-1}}[b\ \ 0]^T$为一个basic solution。


$|M|=|B||I|-0=|B| \neq 0$，所以$M$可逆。$M^{-1}$矩阵为

$$
M^{-1}=\left[\begin{array}{ll}
B^{-1} & -B^{-1}N \\
0 & I
\end{array}\right]
$$
代数上如何决定neighbouring？basic variable只有一个不同（选为BV的变量，并非具体的值）每个BFS有n-m个neighbors（从nbv里选一个进入bv，替换已有的bv，注意替换不是随便替换，需要通过计算把等于0的bv替换走，所以是n-m）
